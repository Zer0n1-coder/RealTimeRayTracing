# 26.6 纹理过滤
&emsp;&emsp;如第3.8节和第23.8节所述，光栅化是对***quads***样的2x2组像素进行着色。这样做是为了使**mipmapping**纹理硬件单元可以计算和使用纹理覆盖域的近似值。对于光线追踪，情况会有所不同。在这里，光线通常是相互独立发射的。我们可以想象这样一个系统：每个***eye ray***有两条额外的光线与三角片平面相交，其中第一条光线水平偏移一个像素，第二条垂直偏移一个像素。在许多情况下，这种技术可以生成精确的纹理过滤器覆盖域，但仅限于***eye ray***。但是，如果相机正在观察反射表面，而反射光线命中纹理表面，会发生什么情况？在这种情况下，最好执行过滤纹理查找，同时考虑反射的性质和光线传播的距离。折射表面也是如此。  
&emsp;&emsp;Igehy利用一种称为光线差分的技术为这个问题提供了一个复杂的解决方案。每一条光线都需要存储作为该光线的附加数据。回想一下，***o***是光线起点，***d***是光线方向(方程式26.1)。由于***o***和***d***都有三个元素，上面的对光线的微分就需要4x3=12个额外的数字来存储这些数据。发射一条光线时，，***∂o/∂x***=***∂o/∂y***=(0,0,0),因为光线是从一个点开始的。然而，***∂d/∂x***和***∂d/∂y***将模拟每束光线通过像素时的扩散量。光线的微分在从一个点传输到另一个点时需要更新。此外，Igehy不仅导出了光线的微分在反射和折射时其是如何变化的公式，还导出了如何计算具有插值法线的三角形的微分法线公式。  
&emsp;&emsp;另一种更简单的方法是基于***tracing cones***，由Amanatides于1984年首次提出[7].在这项工作的重点主要是抗锯齿几何体，但它简要地提到，当进行光线追踪时，***ray cones***也可以用于纹理过滤。AkenineMöller等人[6]提出了一种实现***ray cones***和**G**缓存的方法，其中G缓存还考虑了第一次命中时的曲率。过滤器区域取决于到命中点的距离、光线的扩散、命中点的法线和曲率。但是，由于曲率仅在第一次命中时提供，因此***deep reflections***可能会出现锯齿。他们还提供了与**G**缓存渲染相结合的光线微分变体，并对这些方法进行了比较。  
&emsp;&emsp;四种不同的纹理过滤方法如图26.23所示。使用mip几倍0(即，没有mipmapping)会导致严重的混叠。***ray cones***为该场景提供了稍微更锐利的结果，而光线微分提供的结果更接近实际情况。光线微分通常可以更好地估计纹理区域，但有时也可能过于模糊。根据他们的经验，***ray cones***可以是过度模糊和欠模糊。Akenine-Möller等人提供了用于光线追踪纹理过滤的光线微分和***ray cones***的实现。
