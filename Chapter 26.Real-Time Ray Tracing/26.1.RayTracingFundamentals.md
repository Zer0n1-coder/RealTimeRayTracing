# 26.1 光线追踪基础
&emsp;&emsp;回忆一下方程22.1，其中光线被定义为
$$\overrightarrow {q}(t) = \overrightarrow {o} + t\overrightarrow {d},$$
其中$\overrightarrow {o}$是光线原点，$\overrightarrow {d}$是单位化后的光线方向，t是沿光线方向的距离。请注意，我们在这里使用$\overrightarrow {q}$而不是$\overrightarrow {r}$是为了区分接下来会使用到的右向量$\overrightarrow {r}$。光线追踪可以用***trace***()和***shade***()两个函数来进行描述。其核心的几何算法位于***trace***()中，***trace***()负责查找光线与场景中的片元之间最近的交点，并通过调用***shader***()返回光线的颜色。大多数情况下，我们都想找到一个t>0相交测试结果。对于构造实体几何(constructive solid geometry)，我们通常也需要负距离的交点(位于光线后面的交点)。  
&emsp;&emsp;为了得到一个像素的颜色，我们会向一个像素发射若干条光线，然后计算它们的结果的加权平均值来作为该像素的颜色值。这些光线被称为视线(eye rays)或者相机光线(camera rays)。相机的设置如图26.2所示。给定一个整数像素坐标(x,y)，其中x轴正方向向右，y轴正方向向下，相机位置c，以及坐标框架{$\overrightarrow {r}$,$\overrightarrow {u}$,$\overrightarrow {v}$}(right,up和view)，对于相机，屏幕分辨率为wxh,则计算出的视线方程$\overrightarrow {q}(t) = \overrightarrow {o} + t\overrightarrow {d}$为
$$\overrightarrow {o} = \overrightarrow {c},$$
$$\overrightarrow {s}(x,y) = af(\frac {2(x + 0.5)}{w} - 1)\overrightarrow {r} + f(\frac {2(y + 0.5)}{h} - 1)\overrightarrow {u} +\overrightarrow {v},$$
$$\overrightarrow {d}(x,y) = \frac {\overrightarrow {s}(x,y)}{||\overrightarrow {s}(x,y)||}$$
&emsp;&emsp;其中，单位化的光线方向向量$\overrightarrow {d}$受$f = tan(\frac {\phi}{2})$的影响，$\phi$是相机的竖向视野，$a = w/h$是纵横比。请注意，相机坐标系为左手坐标系，即$\overrightarrow {r}$指向右侧，$\overrightarrow {u}$为上向量，$\overrightarrow {v}$指向由相机到图像平面的方向，即与图4.5所示的设置相似。注意，$\overrightarrow {s}$是一个临时向量，用于单位化$\overrightarrow {d}$。在整数(x,y)位置处加上0.5得到每个像素的中心位置，因为(0.5,0.5)是浮点中心(floating-point center)。如果我们想在要在一个像素中的任何地方发射光线，我们将使用浮点值来表示像素的位置，而不必添加0.5的偏移量。  
&emsp;&emsp;在最简单的实现中，***trace***()将循环遍历场景中所有这些n个片元，并让光线与每个片元求交，包留t>0的最近交点。这样做会产生O(n)性能损失，除非仅有少数的片元，否则这种情况下的执行速度将慢得难以接受。为了以O(logn)的时间复杂度计算每根光线，我们使用空间加速的数据结构，例如BVH或k-d树。有关如何使用BVH计算与光线相交测试的介绍，请参考第19.1章。  
&emsp;&emsp;使用***trace***()和***shader***()来描述光线追踪器会很容易。方程26.2用于从相机位置途径像素内位置生成一条视线。该光线会被传入***trace***()，***trace***()的任务是计算沿着该光线返回的颜色或者辐射度(第8章)。这是通过先找到沿光线最近的交点，然后使用***shade***()来计算该点的着色。我们在图26.3中说明了这个过程。这个概念的强大之处在于***shade***()可以通过对***trace***()的递归调用来计算辐射度。例如，这些利用***trace***()从***shade***()中发射出的新光线可以用于计算阴影、递归反射和折射以及漫反射光线的求值计算。术语“ray depth”用于表示沿光线路径递归发射出的光线数。刚发射的视线的光线深度为1，而***trace***()第二次调用时击中图26.3中圆的光线的光线深度为2。  
&emsp;&emsp;这些新光线的其中一个用途是确定当前将要着色的点相对于光源是否处于阴影之中。这样做就会生成阴影。我们也可以在交点处取视线和法线$\overrightarrow {n}$来计算反射向量。朝这个方向发射的光线会在曲面上产生反射，并且可以递归地进行。同样的过程也可以用来产生折射光线。完美的高光反射和折射还伴随着清晰阴影的效果通常被称为***Whitted ray-tracing***。有关如何计算反射和折射光线的介绍，请参考第9.5节和第14.5.2节。注意，当一个场景对象的折射率与光线传播经过的介质的折射率不同时，该光线可能会同时发生反射和折射。见图26.4。这种情况下的递归是使用基于光栅化渲染的方法难以解决的问题，它仅能使用各种近似方法来实现光线追踪所能取得的效果的一个子集。光线投射(ray casting)，即用于测试两点之间或一个方向上的可见性的思想，可用于其他图形相关的(也可以是非图形相关的)算法。例如，我们可以从一个交点处发射大量的环境遮挡光线，以获得对该处效果的准确计算。
