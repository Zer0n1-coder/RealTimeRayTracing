# 26.2 用于光线跟踪的着色器
光线追踪现在被紧密地集成到实时渲染API中，比如DirectX[59,91,92]和Vulkan。在本节中，我们将描述添加到这些应用编程接口中的不同类型的光线追踪着色器，因此可以与光栅化一起使用。作为这种组合的例子，我们可以首先使用光栅化生成一个G缓冲区(第20章)，然后从这些命中点发射光线，以生成反射和阴影[9,76]。我们称之为延迟光线追踪（deferred ray tracing）。类似于计算着色器（第3.10节），光线追踪着色器被分配到图形处理器，即在（像素）网格上。在本节中，我们遵循DXR[59]的命名约定，这是DirectX12的光线追踪扩充。有五种类型的光线追踪着色器[59,78]。  
1.ray generation shader;  
2.closest hit shader;  
3.miss shader;  
4.any hit shader;  
5.intersection shader.  
除了区间[tmin,tmax]之外，使用等式26.1定义光线。区间定义了射线中接受相交的部分。参见26.7.程序员可以给光线添加***payload***。这是一种用于在不同光线追踪着色器之间发送数据的数据结构。一根光线的***payload***可以包含一个float4类型的辐射率和一个float类型的命中点距离，但是用户可以添加任何需要的东西。然而，保持光线***payload***较小对性能更好，因为更大的***payload***可能使用更多的寄存器。  
***ray generation shader***是光线追踪的起点。它可以像计算着色器一样进行编程，并能够调用一个新的函数***TraceRay***，该函数类似于第26.1节中描述的***Trace***函数。通常，***ray generation shader***对屏幕的所有像素执行。***TraceRay***内部空间加速结构的快速遍历的实现是由驱动程序通过API提供的。可以定义连接到不同着色器的光线类型。例如，标准光线通常使用一组着色器，而阴影光线可以使用更简单的着色器。对于阴影，光线可以更有效地追踪，因为我们通常可以在光线的区间（从命中点到光源的范围）中找到任何相交点后立即停止。  
对于标准光线，需要第一个正交点。这些光线由***ray generation shader***发射。当找到最近的命中点时，执行***closest hit shader***。在这里，用户可以实现第26.1节中的***shade***函数，例如阴影光线测试、反射、折射和路径追踪。如果光线没有命中任何物体，则执行***miss shader***。这对于生成辐射值并通过光线的***payload***返回很有用。这可以时静态背景色、天空色，也可以时使用环境贴图中查询生成的颜色。  
***any hit shader***是一个可选的着色器，可以在场景包含透明对象或通过alpha测试的纹理时使用。每当光线区间中有命中时，就执行该着色器。例如，着色器代码可以在纹理中执行查询。如果采样时完全透明的，那么遍历应该继续，否则可以停止。例如，无法保证这些测试的执行顺序，因此着色器代码可能需要执行一些局部排序来获得正确的混合。***any hit shader***可以实现标准光线和阴影光线。与光栅化一样，在 ***cutout texture***的边界周围使用更紧密的多边形（第13.6.2节）有助于减少调用该着色器的次数。  
