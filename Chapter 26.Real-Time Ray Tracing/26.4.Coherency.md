# 26.4 一致性
软件和硬件性能优化中最重要的思想之一是在执行过程中利用一致性。我们可以通过在给定计算的不同部分重用结果来节省时间。在今天的硬件中，时间和能量消耗最昂贵的操作是内存访问，这比简单的数学操作慢几个数量级。评估硬件操作成本的一个好方法是考虑位于电路内部完成操作所需的物理距离。大多数时间，性能优化侧重于利用内存一致性（缓存）和围绕内存延迟的调度计算。GPU本身可以被视为一个处理器，它明确地约束它运行的程序的执行模型（数据并行、独立计算线程），以便更好地利用内存一致性（第23.1节）。  
在本章的介绍中，我们讨论了屏幕像素（相机光线）的“首次命中”可见性的光线追踪和光栅化如何被视为场景几何体的不同遍历顺序。虽然排序在算法复杂性方面并不重要，但每种排序都有实际的后果。通过光栅化和光线追踪，我们有了一个双for循环。最里面的循环，除非碰巧很小，否则是大多数计算所在之处。由于迭代在内部循环中背靠背地紧挨着发生，它们是通过在迭代之间重用数据和利用内存访问局部性（缓存优化）来减少计算的最佳候选。  
光栅化器的内部循环位于给定对象表面的像素之上。表面上的点很可能表现出高度的一致性计算：它们可能使用相同的材质着色，使用相同的纹理，甚至访问附近位置的这些纹理（内存）。如果我们必须计算大量相机像素的可见性，我们可以很容易地以空间连续的顺序遍历这些位置，例如，在屏幕上的小方块中。这样做确保了内环中高度一致的工作（第23.1节）。请注意，一致性超越了可见性的问题。渲染通常在我们知道什么表面是可见的之后开始——大量的工作在于计算材料属性及其与场景照明的交互。光栅化速度特别快，不仅因为它可以有效地计算出哪些对象覆盖了哪些像素，还因为后续的着色工作是以利用一致性的方式自然排序的。  
相比之下，对于外部循环中的给定光线，原始光线追踪器迭代内部循环中的所有场景图元。不管我们如何避免来自m个像素和n个对象的O（mn）双循环的总体开销，当沿着单个光线遍历渲染图元的单个列表时，几乎没有一致性可利用。  
