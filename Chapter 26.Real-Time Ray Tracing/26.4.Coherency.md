# 26.4 一致性
软件和硬件性能优化中最重要的思想之一是在执行过程中利用一致性。我们可以通过在给定计算的不同部分重用结果来节省时间。在今天的硬件中，时间和能量消耗最昂贵的操作是内存访问，这比简单的数学操作慢几个数量级。评估硬件操作成本的一个好方法是考虑位于电路内部完成操作所需的物理距离。大多数时间，性能优化侧重于利用内存一致性（缓存）和围绕内存延迟的调度计算。GPU本身可以被视为一个处理器，它明确地约束它运行的程序的执行模型（数据并行、独立计算线程），以便更好地利用内存一致性（第23.1节）。  
在本章的介绍中，我们讨论了屏幕像素（相机光线）的“首次命中”可见性的光线追踪和光栅化如何被视为场景几何体的不同遍历顺序。虽然排序在算法复杂性方面并不重要，但每种排序都有实际的后果。通过光栅化和光线追踪，我们有了一个双for循环。最里面的循环，除非碰巧很小，否则是大多数计算所在之处。由于迭代在内部循环中背靠背地紧挨着发生，它们是通过在迭代之间重用数据和利用内存访问局部性（缓存优化）来减少计算的最佳候选。  
光栅化器的内部循环位于给定对象表面的像素之上。表面上的点很可能表现出高度的一致性计算：它们可能使用相同的材质着色，使用相同的纹理，甚至访问附近位置的这些纹理（内存）。如果我们必须计算大量相机像素的可见性，我们可以很容易地以空间连续的顺序遍历这些位置，例如，在屏幕上的小方块中。这样做确保了内环中高度一致的工作（第23.1节）。请注意，一致性超越了可见性的问题。渲染通常在我们知道什么表面是可见的之后开始——大量的工作在于计算材料属性及其与场景照明的交互。光栅化速度特别快，不仅因为它可以有效地计算出哪些对象覆盖了哪些像素，还因为后续的着色工作是以利用一致性的方式自然排序的。  
相比之下，对于外部循环中的给定光线，原始光线追踪器迭代内部循环中的所有场景图元。不管我们如何避免来自m个像素和n个对象的O（mn）双循环的总体开销，当沿着单个光线遍历渲染图元的单个列表时，几乎没有一致性可利用。  
因此，现代光线追踪器中的大多数性能优化都是处理如何在光线可见性查询和后续阴影计算中“找到”一致性。我们可以说光栅化默认时一致性的，但是受限于特定的可见性查询，即相机视锥体。当使用光栅化技术时，大部分工作涉及如何扩展这个查询函数，以便模拟各种效果。相比之下，光线追踪在默认情况下时灵活的。我们可以从任何方向的任何点查询可见性。然而，这样做天真地导致不一致的计算，这在现代硬件架构上时无效的，因此大部分的工程努力都花费在试图以一致的方式组织可见性查询上。  
随着光线查询灵活性的增加，我们可以渲染光栅化器无法渲染的效果，同时通过利用一致性来保持高性能。阴影就是一个很好的例子。追踪阴影光线使我们能够更精确地模拟区域光的效果[35]。阴影光线只需要与集合体相交，大多数情况下不需要评估材质。这些属性降低了命中不同物体的成本。相对于阴影光线，我们需要评估的只是光线是否命中了交点和光源之间的任何物体。因此，我们可以避免计算交点处的法线，避免实体对象的纹理，并且可以在找到第一个实体后停止追踪。此外，阴影光线通常是高度相干的。对于屏幕上的邻近像素，它们具有相似的远点，并且可以指向相同的光。最后，阴影贴图（第7.4节）无法以屏幕像素的精确频率对光可见度进行采样，导致多采样不足或过采样。在后一种情况下，增加阴影光线的灵活性甚至可以带来更好的性能。光线通常更昂贵，但是通过避免过采样，我们可以执行更少的可见性查询。这也是为什么阴影贴图是游戏中光线追踪的第一个图形应用[90]。
