# 26.4 一致性
软件和硬件性能优化中最重要的思想之一是在执行过程中利用一致性。我们可以通过在给定计算的不同部分重用结果来节省时间。在今天的硬件中，时间和能量消耗最昂贵的操作是内存访问，这比简单的数学操作慢几个数量级。评估硬件操作成本的一个好方法是考虑位于电路内部完成操作所需的物理距离。大多数时间，性能优化侧重于利用内存一致性（缓存）和围绕内存延迟的调度计算。GPU本身可以被视为一个处理器，它明确地约束它运行的程序的执行模型（数据并行、独立计算线程），以便更好地利用内存一致性（第23.1节）。  
在本章的介绍中，我们讨论了屏幕像素（相机光线）的“首次命中”可见性的光线追踪和光栅化如何被视为场景几何体的不同遍历顺序。虽然排序在算法复杂性方面并不重要，但每种排序都有实际的后果。通过光栅化和光线追踪，我们有了一个双for循环。最里面的循环，除非碰巧很小，否则是大多数计算所在之处。由于迭代在内部循环中背靠背地紧挨着发生，它们是通过在迭代之间重用数据和利用内存访问局部性（缓存优化）来减少计算的最佳候选。  
光栅化器的内部循环位于给定对象表面的像素之上。表面上的点很可能表现出高度的一致性计算：它们可能使用相同的材质着色，使用相同的纹理，甚至访问附近位置的这些纹理（内存）。如果我们必须计算大量相机像素的可见性，我们可以很容易地以空间连续的顺序遍历这些位置，例如，在屏幕上的小方块中。这样做确保了内环中高度一致的工作（第23.1节）。请注意，一致性超越了可见性的问题。渲染通常在我们知道什么表面是可见的之后开始——大量的工作在于计算材料属性及其与场景照明的交互。光栅化速度特别快，不仅因为它可以有效地计算出哪些对象覆盖了哪些像素，还因为后续的着色工作是以利用一致性的方式自然排序的。  
相比之下，对于外部循环中的给定光线，原始光线追踪器迭代内部循环中的所有场景图元。不管我们如何避免来自m个像素和n个对象的O（mn）双循环的总体开销，当沿着单个光线遍历渲染图元的单个列表时，几乎没有一致性可利用。  
因此，现代光线追踪器中的大多数性能优化都是处理如何在光线可见性查询和后续阴影计算中“找到”一致性。我们可以说光栅化默认时一致性的，但是受限于特定的可见性查询，即相机视锥体。当使用光栅化技术时，大部分工作涉及如何扩展这个查询函数，以便模拟各种效果。相比之下，光线追踪在默认情况下时灵活的。我们可以从任何方向的任何点查询可见性。然而，这样做天真地导致不一致的计算，这在现代硬件架构上时无效的，因此大部分的工程努力都花费在试图以一致的方式组织可见性查询上。  
随着光线查询灵活性的增加，我们可以渲染光栅化器无法渲染的效果，同时通过利用一致性来保持高性能。阴影就是一个很好的例子。追踪阴影光线使我们能够更精确地模拟区域光的效果[35]。阴影光线只需要与集合体相交，大多数情况下不需要评估材质。这些属性降低了命中不同物体的成本。相对于阴影光线，我们需要评估的只是光线是否命中了交点和光源之间的任何物体。因此，我们可以避免计算交点处的法线，避免实体对象的纹理，并且可以在找到第一个实体后停止追踪。此外，阴影光线通常是高度相干的。对于屏幕上的邻近像素，它们具有相似的远点，并且可以指向相同的光。最后，阴影贴图（第7.4节）无法以屏幕像素的精确频率对光可见度进行采样，导致多采样不足或过采样。在后一种情况下，增加阴影光线的灵活性甚至可以带来更好的性能。光线通常更昂贵，但是通过避免过采样，我们可以执行更少的可见性查询。这也是为什么阴影贴图是游戏中光线追踪的第一个图形应用[90]。
## 26.4.1 场景一致性
当我们考虑它们之间的距离时，三维场景中的图元属于自然空间关系。当我们想到渲染需要的着色工作时，这些关系不一定保证计算的一致性。例如，一个对象可能与另一个对象很接近，但使用完全不同的材质、纹理和最终的着色算法。大多数用于加速光线追踪器中对象遍历的算法和数据结构也可以适用于光栅化器，如第19.1节所述。然而，这些数据结构在光线追踪器中对象遍历的算法和数据结构也可以适用于光栅化器更重要。追踪光线时，对象遍历是内部循环的一部分。  
大多数光线追踪器和光线追踪API使用某种形式的空间加速数据结构来加速光线可见性查询。在许多情况下，包括DXR的当前版本，这些技术对用户来说是不透明的，是幕后实现的，并作为黑盒功能提供。因此，如果您专注于理解基本DXR功能和相关技术，那么可以跳过关于一致性的这一部分的剩余部分。然而，如果你想掌握性能，尤其是对于较大场景，这一部分很重要。如果您知道您的系统依赖于特定的空间结构，了解与该方案相关的优势和成本可以帮助您提高渲染引擎的效率。  
创建数据结构来利用可见性计算中的场景一致性对于实时渲染来说尤其具有挑战性，因为在大多数情况下，场景会在动画中逐帧改变。事实上，虽然我们之前提到了光线追踪器的外循环如何在可见性查询中允许更大的灵活性，但是光栅化器的外循环可以更自然地处理动画场景，以及程序生成的和核心外的（太大了，无法同时容纳在内存中）几何体。光栅化的循环结构是这些空间数据结构通常以相对简化的形式出现在基于光栅化的渲染解决方案中的另一个原因。  
空间数据结构背后的思想是，我们可以通过将场景中彼此靠近的对象分组在同一个体积中的方式来组织空间分区内的几何体。实现这种划分的一个简单方法是在一个规则的网格中细分整个场景，并在每个立方体（体素）中存储与其相交的图元列表。然后，光线遍历可以通过访问光线方向给定的一行中的每个单元格来完成，从光线原点开始。遍历是和***conservative line rasterization***一样的算法，只不过是在三维上。基本思想是找到x、y和z方向上到下一个体素的距离，取其中最小的一个，沿着光线移动到那个体素。图26.10中最左边的插图显示了光线如何访问均匀网格中的单元。这三个值随后被更新，并且新的最小值被用于移动到下一个体素。每次我们在遍历过程中发现一个非空的单元，我们都需要针对单元中包含的所有图元来测试光线。一旦我们单元格中找到命中，网格中的遍历就不需要继续了。对于阴影光线（任何命中），我们可以简单地停止，但是对于标准光线，我们需要测试单元中的所有图元，并选择最近的图元。Havran的论文[31]提供了一个全面的概述。  
由于一个场景可能有小而详细的对象，在一些区域中许多微笑的图元，而在另一些区域有大而粗糙的图元，固定的网格大小可能在所有地方都不起作用。这种情况被称为“***teapot in a stadium***”问题[27]，其中一个复杂的茶壶（注意力的焦点）落入一个单元中，因此无法从效率结构中获益。尽管简单的均匀网格构造速度快，遍历简单，但目前很少用于大多数光线追踪。存在提高网格效率的变体，因此更加实用。网格可以以分层的方式嵌套，更高级别的大单元格根据需要包含更精细的网格。两级嵌套网格在GPU上并行构建速度特别快[42]，并已成功应用于早期动画GPU实时光线追踪演示[80]。  
哈希表可以用来创建一个无限的虚拟网格，其中只有被占用的单元在内存中存储数据（第25.1.2节）。另一种策略是在空单元格中存储以网格单位表示的最近的非空单元格的距离。这个系统被称为***proximity clouds***[14]。在遍历过程中，这些距离允许我们安全地扫描许多块。最近，***irregular grids***[64]阐述了高效跳过空白空间的想法。这些已被证明在动画场景的光线追踪的空间加速方面与最先进的技术相竞争。图36.10显示了这些网格变体中的一些。  
如果我们将分层网格的思想发展到极限，我们可以想想将分辨率最低的网格（由每个轴上的两个单元格组成）作为顶层数据结构，并将每个非空单元格递归拆分为另一个2x2x2的单元格。这个结构是一个八叉树，在第19.1.3节中讨论。更进一步，我们可以想象在分层数据接哦古的每一层使用一个平面将一个的单元格一分为二。如果平面选择是任意的，则生成二进制BSP数，如果平面被约束为轴对齐，则生成K-D树（第19.1.2节）。如果我们在数据结构的每一层使用一对，而不是使用单个轴对齐的平面，我们就获得了一个有界区间层次（BIH）树[84]，它具有与之相关联的快速构造算法。  
今天，最流行的光线追踪加速结构是包围盒层次结构（BVH），在第19.1.1节中有所描述。参见图26.11.例如，英特尔的Embree内核[88]，AMD的Radeon-ray库[8]，英伟达的RT Cores硬件[58]和OptiX系统[62]都使用了分层包围盒结构。
