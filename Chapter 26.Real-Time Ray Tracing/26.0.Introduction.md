# 26.0 引言
&emsp;&emsp;与基于光栅化的技术(这是本书大部分内容的主题)相比，光线追踪是一种更直接地受光的物理性质(the physics of light)启发得到的方法。因此，它可以生成更真实的图像。在1999年的《Real-Time Rendering》第一版中，我们梦想着在2007到2024间，渲染一个《A Bug’ Life》(ABL)的平均帧(average frame)能达到每秒12帧。从某种意义上来说，我们是对的。ABL只在一些真正需要的地方使用了光线追踪，例如水滴中的反射和折射。然而，最近GPU的进步使得使用光线追踪进行实时渲染游戏场景成为可能。例如，本书的封面展示了一个场景，它使用全局光照以每秒大约20帧的速度进行渲染得到，并开始呈现出类似于影片的画面质量。光线追踪将彻底改变实时渲染。
    在最简单的形式中，光栅化和光线追踪的可见性决议(visibility determination)都可以通过双循环来进行描述，光栅化的是：
```
for(T in triangles)
	for(P in pixels)
		determine if P is inside T
```
&emsp;&emsp;另一方面，光线追踪可以用以下方式描述：
```
for(P in pixels)
	for(T in triangles)
		determine if ray through P hits T
```
&emsp;&emsp;所以在某种意义上，上面这两段代码都是简单的算法。然而，想要使这两段代码中的某一段快速运行，你需要的代码和硬件会远远超过一张名片(注:上世纪90年代保罗·赫克伯特名片的背面有一个简单的递归光线跟踪器的代码)所能容下的大小。使用空间数据结构(例如，bounding volume hierarchy (BVH))的光线追踪器的一个重要特点是，追踪一条光线的时间复杂度是O(logn)，其中n是场景中三角片的数量。虽然这是光线追踪一个吸引人的特点，但是很明显，光栅化也比O(n)要好，因为GPU有遮挡剔除的硬件支持，渲染引擎使用了视锥体剔除、延迟着色以及许多其他避免完全处理每一个片元的技术。因此，用O()表示法来估算光栅化的运行时间是一件困难的事。此外，GPU的纹理单元和三角形遍历单元的速度非常快，并且已经经过了几十年的优化。
    这两者的重要区别在于光线追踪可以向任意方向发射光线，而不是对单个顶点进行处理，例如从眼睛或者光源处。正如我们将在26.1节中看到的，这种灵活性使得递归地渲染反射和折射以及完全计算渲染方程成为可能。这样做只会使图像看起来更好。光线追踪的这种特点也简化了内容的创作，因为需要更少的艺术家去干预。当使用光栅化时，艺术家通常需要调整他们的创作，以便完美契合渲染技术的使用。但是，使用光线追踪，噪声可能会在图像中变得明显。例如，当对区域光进行采样，物体表面是玻璃材质、环境贴图被整合到上面以及使用路径追踪的时候，都可能发生这种情况。
    也就是说，要使实时光线追踪成为用于实时应用的唯一渲染算法。很可能需要一些技术，例如去噪技术，来使图像看起来足够好。基于智能图像平均算法(intelligent image averaging)(第26.5节)的去噪技术尝试用来去除噪声。在短期内，光栅化和光线追踪的巧妙结合预计不会很快消失。从长远来看，光线追踪的规模和处理器会变得更强大，也就是说，提供的计算和带宽越多，通过增加每一像素的采样数和递归光线的深度，我们就可以利用光线追踪生成更好的图像。例如，由于间接光追的困难，使用了每一像素256个采样数才生成图26.1中的图像效果。另一个具有高质量路径追踪的图像如图26.6所示，其中每一像素使用了从1到65536不等的采样数。
    在深入研究光线追踪中使用的算法之前，我们先向你介绍几个相关的章节。关于全局光照的第11章已经提供了围绕渲染方程(方程式11.2)的理论，以及第11.2.2节中光线和路径追踪的基本解释。第22章描述了求交的方法，其中光线对物体的相交测试对于光线追踪是必不可少的。空间数据结构用于加速光线追踪中的可见性查询，有关碰撞检测的内容第19.1.1节和第25章进行了描述。
